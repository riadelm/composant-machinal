'use strict';

const allowLayers = [
    1,
    3 // RGB
];

const markers = [
    0xc0,
    0xc1,
    0xc2,
    0xc3,
    0xc5,
    0xc6,
    0xc7,
    0xc9,
    0xca,
    0xcb,
    0xcd,
    0xce,
    0xcf // ("SOF15", "Differential spatial (AC)", SOF)
];

const sizes = {
    squareSide: [
        // Safari (iOS < 9, ram >= 256)
        // We are supported mobile safari < 9 since widget v2, by 5 Mpx limit
        // so it's better to continue support despite the absence of this browser in the support table
        Math.floor(Math.sqrt(5 * 1000 * 1000)),
        // IE Mobile (Windows Phone 8.x)
        // Safari (iOS >= 9)
        4096,
        // IE 9 (Win)
        8192,
        // Firefox 63 (Mac, Win)
        11180,
        // Chrome 68 (Android 6)
        10836,
        // Chrome 68 (Android 5)
        11402,
        // Chrome 68 (Android 7.1-9)
        14188,
        // Chrome 70 (Mac, Win)
        // Chrome 68 (Android 4.4)
        // Edge 17 (Win)
        // Safari 7-12 (Mac)
        16384
    ],
    dimension: [
        // IE Mobile (Windows Phone 8.x)
        4096,
        // IE 9 (Win)
        8192,
        // Edge 17 (Win)
        // IE11 (Win)
        16384,
        // Chrome 70 (Mac, Win)
        // Chrome 68 (Android 4.4-9)
        // Firefox 63 (Mac, Win)
        32767,
        // Chrome 83 (Mac, Win)
        // Safari 7-12 (Mac)
        // Safari (iOS 9-12)
        // Actually Safari has a much bigger limits - 4194303 of width and 8388607 of height,
        // but we will not use them
        65535
    ]
};

const memoize = (fn, serializer) => {
    const cache = {};
    return (...args) => {
        const key = serializer(args, cache);
        return key in cache ? cache[key] : (cache[key] = fn(...args));
    };
};
/**
 * Memoization key serealizer, that prevents unnecessary canvas tests. No need
 * to make test if we know that:
 *
 * - Browser supports higher canvas size
 * - Browser doesn't support lower canvas size
 */
const memoKeySerializer = (args, cache) => {
    const [w] = args;
    const cachedWidths = Object.keys(cache)
        .map((val) => parseInt(val, 10))
        .sort((a, b) => a - b);
    for (let i = 0; i < cachedWidths.length; i++) {
        const cachedWidth = cachedWidths[i];
        const isSupported = !!cache[cachedWidth];
        // higher supported canvas size, return it
        if (cachedWidth > w && isSupported) {
            return cachedWidth;
        }
        // lower unsupported canvas size, return it
        if (cachedWidth < w && !isSupported) {
            return cachedWidth;
        }
    }
    // use canvas width as the key,
    // because we're doing dimension test by width - [dimension, 1]
    return w;
};

const createCanvas = () => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    return {
        canvas,
        ctx
    };
};

// add constants
const TestPixel = {
    R: 55,
    G: 110,
    B: 165,
    A: 255
};
const FILL_STYLE = `rgba(${TestPixel.R}, ${TestPixel.G}, ${TestPixel.B}, ${TestPixel.A / 255})`;
const canvasTest = (width, height) => {
    try {
        const fill = [width - 1, height - 1, 1, 1]; // x, y, width, height
        const { canvas: cropCvs, ctx: cropCtx } = createCanvas();
        cropCvs.width = 1;
        cropCvs.height = 1;
        const { canvas: testCvs, ctx: testCtx } = createCanvas();
        testCvs.width = width;
        testCvs.height = height;
        if (testCtx) {
            testCtx.fillStyle = FILL_STYLE;
            testCtx.fillRect(...fill);
            // Render the test pixel in the bottom-right corner of the
            // test canvas in the top-left of the 1x1 crop canvas. This
            // dramatically reducing the time for getImageData to complete.
            cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);
        }
        const imageData = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data;
        let isTestPass = false;
        if (imageData) {
            // On IE10, imageData have type CanvasPixelArray, not Uint8ClampedArray.
            // CanvasPixelArray supports index access operations only.
            // Array buffers can't be destructuredd and compared with JSON.stringify
            isTestPass =
                imageData[0] === TestPixel.R &&
                    imageData[1] === TestPixel.G &&
                    imageData[2] === TestPixel.B &&
                    imageData[3] === TestPixel.A;
        }
        testCvs.width = testCvs.height = 1;
        return isTestPass;
    }
    catch (e) {
        console.error(`Failed to test for max canvas size of ${width}x${height}.`);
        return false;
    }
};

function wrapAsync(fn) {
    return (...args) => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const result = fn(...args);
                resolve(result);
            }, 0);
        });
    };
}
const squareTest = wrapAsync(memoize(canvasTest, memoKeySerializer));
const dimensionTest = wrapAsync(memoize(canvasTest, memoKeySerializer));
const testCanvasSize = (w, h) => {
    return new Promise((resolve, reject) => {
        const testSquareSide = sizes.squareSide.find((side) => side * side >= w * h);
        const testDimension = sizes.dimension.find((side) => side >= w && side >= h);
        if (!testSquareSide || !testDimension) {
            reject();
            return;
        }
        Promise.all([
            squareTest(testSquareSide, testSquareSide),
            dimensionTest(testDimension, 1)
        ]).then(([squareSupported, dimensionSupported]) => {
            if (squareSupported && dimensionSupported) {
                resolve(true);
            }
            else {
                reject();
            }
        });
    });
};

const canvasResize = (img, w, h) => {
    return new Promise((resolve, reject) => {
        try {
            const { ctx, canvas } = createCanvas();
            canvas.width = w;
            canvas.height = h;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, w, h);
            img.src = '//:0'; // for image
            img.width = img.height = 1; // for canvas
            resolve(canvas);
        }
        catch (e) {
            reject(`Failed to resize image. ${e}`);
        }
    });
};

const native = ({ img, targetW, targetH }) => canvasResize(img, targetW, targetH);

const calcShrinkSteps = function (sourceW, targetW, targetH, step) {
    const steps = [];
    let sW = targetW;
    let sH = targetH;
    // result should include at least one target step,
    // even if abs(source - target) < step * source
    // just to be sure nothing will break
    // if the original resolution / target resolution condition changes
    do {
        steps.push([sW, sH]);
        sW = Math.round(sW / step);
        sH = Math.round(sH / step);
    } while (sW < sourceW * step);
    return steps.reverse();
};
const fallback = ({ img, sourceW, targetW, targetH, step }) => {
    const steps = calcShrinkSteps(sourceW, targetW, targetH, step);
    return steps
        .reduce((chain, [w, h]) => {
        return chain
            .then((canvas) => {
            return testCanvasSize(w, h)
                .then(() => canvas)
                .catch(() => canvasResize(canvas, w, h));
        })
            .then((canvas) => {
            const progress = (sourceW - w) / (sourceW - targetW);
            return { canvas, progress };
        });
    }, Promise.resolve(img))
        .then(({ canvas }) => canvas)
        .catch((error) => Promise.reject(error));
};

const isIOS = () => {
    if (/iPad|iPhone|iPod/.test(navigator.platform)) {
        return true;
    }
    else {
        return (navigator.maxTouchPoints &&
            navigator.maxTouchPoints > 2 &&
            /MacIntel/.test(navigator.platform));
    }
};
const isIpadOS = navigator.maxTouchPoints &&
    navigator.maxTouchPoints > 2 &&
    /MacIntel/.test(navigator.platform);

const STEP = 0.71; // should be > sqrt(0.5)
const shrinkImage = (img, settings) => {
    return new Promise((resolve, reject) => {
        if (img.width * STEP * img.height * STEP < settings.size) {
            reject('Not required');
        }
        const sourceW = img.width;
        const sourceH = img.height;
        const ratio = sourceW / sourceH;
        // target size shouldn't be greater than settings.size in any case
        const targetW = Math.floor(Math.sqrt(settings.size * ratio));
        const targetH = Math.floor(settings.size / Math.sqrt(settings.size * ratio));
        return testCanvasSize(targetW, targetH)
            .then(() => {
            const { ctx } = createCanvas();
            const supportNative = 'imageSmoothingQuality' in ctx;
            const useNativeScaling = supportNative && !isIOS() && !isIpadOS;
            return useNativeScaling
                ? native({ img, targetW, targetH })
                : fallback({ img, sourceW, targetW, targetH, step: STEP });
        })
            .then((canvas) => resolve(canvas))
            .catch(() => reject('Not supported'));
    });
};

const readJpegChunks = () => {
    const stack = [];
    const promiseReadJpegChunks = (file) => new Promise((resolve, reject) => {
        let pos;
        const readToView = (file, cb) => {
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                cb(new DataView(reader.result));
            });
            reader.addEventListener('error', (e) => {
                reject(`Reader error: ${e}`);
            });
            reader.readAsArrayBuffer(file);
        };
        const readNext = () => readToView(file.slice(pos, pos + 128), (view) => {
            let i, j, ref;
            for (i = j = 0, ref = view.byteLength; ref >= 0 ? j < ref : j > ref; i = ref >= 0 ? ++j : --j) {
                if (view.getUint8(i) === 0xff) {
                    pos += i;
                    break;
                }
            }
            return readNextChunk();
        });
        const readNextChunk = () => {
            const startPos = pos;
            return readToView(file.slice(pos, (pos += 4)), (view) => {
                if (view.byteLength !== 4 || view.getUint8(0) !== 0xff) {
                    return reject('Corrupted');
                }
                const marker = view?.getUint8(1);
                if (marker === 0xda) {
                    return resolve(true);
                }
                const length = view.getUint16(2) - 2;
                return readToView(file.slice(pos, (pos += length)), (view) => {
                    if (view.byteLength !== length) {
                        return reject('Corrupted');
                    }
                    stack.push({ startPos, length, marker, view });
                    return readNext();
                });
            });
        };
        if (!(FileReader && DataView)) {
            reject('Not Support');
        }
        pos = 2;
        readToView(file.slice(0, 2), function (view) {
            if (view.getUint16(0) !== 0xffd8) {
                reject('Not jpeg');
            }
            return readNext();
        });
    });
    return {
        stack,
        promiseReadJpegChunks
    };
};

const replaceJpegChunk = (blob, marker, chunks) => {
    return new Promise((resolve, reject) => {
        const oldChunkPos = [];
        const oldChunkLength = [];
        const { promiseReadJpegChunks, stack } = readJpegChunks();
        return promiseReadJpegChunks(blob)
            .then(() => {
            stack.forEach((chunk) => {
                if (chunk.marker === marker) {
                    oldChunkPos.push(chunk.startPos);
                    return oldChunkLength.push(chunk.length);
                }
            });
        })
            .then(() => {
            const newChunks = [blob.slice(0, 2)];
            for (const chunk of chunks) {
                const intro = new DataView(new ArrayBuffer(4));
                intro.setUint16(0, 0xff00 + marker);
                intro.setUint16(2, chunk.byteLength + 2);
                newChunks.push(intro.buffer);
                newChunks.push(chunk);
            }
            let pos = 2;
            for (let i = 0; i < oldChunkPos.length; i++) {
                if (oldChunkPos[i] > pos) {
                    newChunks.push(blob.slice(pos, oldChunkPos[i]));
                }
                pos = oldChunkPos[i] + oldChunkLength[i] + 4;
            }
            newChunks.push(blob.slice(pos, blob.size));
            resolve(new Blob(newChunks, {
                type: blob.type
            }));
        })
            .catch(() => reject(blob));
    }).catch(() => blob);
};

const MARKER = 0xe2;
const replaceIccProfile = (blob, iccProfiles) => {
    return replaceJpegChunk(blob, MARKER, iccProfiles.map((chunk) => chunk.buffer));
};

const processImage = (image, src) => {
    return new Promise((resolve, reject) => {
        if (src) {
            image.src = src;
        }
        if (image.complete) {
            resolve(image);
        }
        else {
            image.addEventListener('load', () => {
                resolve(image);
            });
            image.addEventListener('error', () => {
                reject(image);
            });
        }
    });
};
const imageLoader = (image) => {
    return processImage(new Image(), image);
};

const stripIccProfile = async (inputFile) => {
    try {
        const file = await replaceIccProfile(inputFile, []);
        const image = await imageLoader(URL.createObjectURL(file));
        URL.revokeObjectURL(image.src);
        return image;
    }
    catch (e) {
        throw new Error(`Failed to strip ICC profile and not image ${e}`);
    }
};

const shouldSkipShrink = async (file) => {
    let skip = false;
    const { promiseReadJpegChunks, stack } = readJpegChunks();
    return await promiseReadJpegChunks(file)
        .then(() => {
        stack.forEach(({ marker, view }) => {
            if (!skip && markers.indexOf(marker) >= 0) {
                const layer = view.getUint8(5);
                if (allowLayers.indexOf(layer) < 0) {
                    skip = true;
                }
            }
        });
        return skip;
    })
        .catch(() => skip);
};

const canvasToBlob = (canvas, type, quality, callback) => {
    return canvas.toBlob(callback, type, quality);
};

const hasTransparency = (img) => {
    const canvasSize = 50;
    // Create a canvas element and get 2D rendering context
    const { ctx, canvas } = createCanvas();
    canvas.width = canvas.height = canvasSize;
    // Draw the image onto the canvas
    ctx.drawImage(img, 0, 0, canvasSize, canvasSize);
    // Get the image data
    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize).data;
    // Reset the canvas dimensions
    canvas.width = canvas.height = 1;
    // Check for transparency in the alpha channel
    for (let i = 3; i < imageData.length; i += 4) {
        if (imageData[i] < 254) {
            return true;
        }
    }
    // No transparency found
    return false;
};

const base64ImageSrc = 'data:image/jpg;base64,' +
    '/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEo' +
    'AAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////' +
    '////////////////////////////////////////////////////////wAALCAABAAIBASIA' +
    '/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';
let isApplied;
const isBrowserApplyExif = () => {
    return new Promise((resolve) => {
        if (isApplied !== undefined) {
            resolve(isApplied);
        }
        else {
            const image = new Image();
            image.addEventListener('load', () => {
                isApplied = image.naturalWidth < image.naturalHeight;
                image.src = '//:0';
                resolve(isApplied);
            });
            image.src = base64ImageSrc;
        }
    });
};

const getExif = async (file) => {
    let isExif = null;
    const { promiseReadJpegChunks, stack } = readJpegChunks();
    return promiseReadJpegChunks(file)
        .then(() => {
        stack.forEach(({ marker, view }) => {
            if (!isExif && marker === 0xe1) {
                if (view.byteLength >= 14) {
                    if (
                    // check for "Exif\0"
                    view.getUint32(0) === 0x45786966 &&
                        view.getUint16(4) === 0) {
                        isExif = view;
                        return isExif;
                    }
                }
            }
            return isExif;
        });
    })
        .catch(() => isExif);
};

const getIccProfile = async (file) => {
    const iccProfile = [];
    const { promiseReadJpegChunks, stack } = readJpegChunks();
    return await promiseReadJpegChunks(file)
        .then(() => {
        stack.forEach(({ marker, view }) => {
            if (marker === 0xe2) {
                if (
                // check for "ICC_PROFILE\0"
                view.getUint32(0) === 0x4943435f &&
                    view.getUint32(4) === 0x50524f46 &&
                    view.getUint32(8) === 0x494c4500) {
                    iccProfile.push(view);
                }
            }
        });
        return iccProfile;
    })
        .catch(() => iccProfile);
};

const findExifOrientation = (exif, exifCallback) => {
    let j, little, offset, ref;
    if (!exif ||
        exif.byteLength < 14 ||
        exif.getUint32(0) !== 0x45786966 ||
        exif.getUint16(4) !== 0) {
        return null;
    }
    if (exif.getUint16(6) === 0x4949) {
        little = true;
    }
    else if (exif.getUint16(6) === 0x4d4d) {
        little = false;
    }
    else {
        return null;
    }
    if (exif.getUint16(8, little) !== 0x002a) {
        return null;
    }
    offset = 8 + exif.getUint32(10, little);
    const count = exif.getUint16(offset - 2, little);
    for (j = 0, ref = count; ref >= 0 ? j < ref : j > ref; ref >= 0 ? ++j : --j) {
        if (exif.byteLength < offset + 10) {
            return null;
        }
        if (exif.getUint16(offset, little) === 0x0112) {
            return exifCallback(offset + 8, little);
        }
        offset += 12;
    }
    return null;
};

const setExifOrientation = (exif, orientation) => {
    findExifOrientation(exif, (offset, little) => exif.setUint16(offset, orientation, little));
};
const replaceExif = async (file, exif, isExifApplied) => {
    if (isExifApplied) {
        setExifOrientation(exif, 1);
    }
    return replaceJpegChunk(file, 0xe1, [exif.buffer]);
};

const shrinkFile = (file, settings) => {
    /*eslint no-async-promise-executor: "off"*/
    return new Promise(async (resolve, reject) => {
        if (!(URL && DataView && Blob)) {
            reject('Not support');
        }
        try {
            const image = await shouldSkipShrink(file)
                .then((shouldSkip) => {
                if (shouldSkip) {
                    return reject('Should skipped');
                }
            })
                .then(() => {
                return stripIccProfile(file).catch(() => {
                    reject('Failed to strip ICC profile and not image');
                });
            });
            const exifList = Promise.allSettled([
                getExif(file),
                isBrowserApplyExif(),
                getIccProfile(file)
            ]);
            exifList.then(async (results) => {
                const isRejected = results.some((result) => result.status === 'rejected');
                const [exif, isExifApplied, iccProfile] = results;
                const isJPEG = !isRejected;
                return shrinkImage(image, settings)
                    .then(async (canvas) => {
                    let format = 'image/jpeg';
                    let quality = settings?.quality || 0.8;
                    if (!isJPEG && hasTransparency(canvas)) {
                        format = 'image/png';
                        quality = undefined;
                    }
                    canvasToBlob(canvas, format, quality, (blob) => {
                        canvas.width = canvas.height = 1;
                        let replaceChain = Promise.resolve(blob);
                        if (exif.value) {
                            replaceChain = replaceChain
                                .then((blob) => replaceExif(blob, exif.value, isExifApplied.value))
                                .catch(() => blob);
                        }
                        if (iccProfile?.value?.length > 0) {
                            replaceChain = replaceChain
                                .then((blob) => replaceIccProfile(blob, iccProfile.value))
                                .catch(() => blob);
                        }
                        replaceChain.then(resolve).catch(() => resolve(blob));
                    });
                })
                    .catch(() => reject(file));
            });
        }
        catch (e) {
            reject(`Failed to shrink image: ${e}`);
        }
    });
};

exports.shrinkFile = shrinkFile;
